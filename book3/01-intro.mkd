% Python for Everybody
% Exploring Data Using Python 3
% Charles R. Severance

为什么要学编程？
=======================================

编程是一项极具创造性和有益的活动。编程的原因很多，大到为谋生去解决一个困难的数据分析问题，小到因
为帮助别人解决一个问题而获得快乐。本书假定 *每个人* 都需要知道怎样编程，一旦学会编程，你就会想要
用这个新技能做些什么了。

我们的日常生活中计算机无处不在，大到笔记本电脑，小到手机。这些计算机可视为帮助我们打理很多事情的
“私人助理”。 在本质上，如今计算机硬件的构建，就是在不断地问我们一个问题，即“你（用户）想让我（计
算机）下一步做什么”。

![个人数字助理](height=1.0in@../images/pda)

程序员在硬件之上添加了操作系统和应用程序，我们手中拿到的成品是一个很有用的个人数字助理（PDA，
Personal Digital Assistant），它能够帮我们处理很多不同的事情。

计算机运行速度很快并拥有大量的内存，如果我们学会了与计算机沟通的语言，告诉计算机我们想要它“接下
来做什么”，那么它就会对我们有非常大的帮助。我们能让计算机根据我们的意愿完成一些重复性工作。有趣
的是，计算机能够胜任并且做得很好的工作通常是那些让我们人类感到无聊、令人头脑麻木的事情。

例如，阅读本章的前三段，找出出现频率最高的词是哪一个，以及这个词总共出现了多少次。尽管你能在短时
间内阅读和理解这些文字，但要对它们进行统计就很痛苦了，因为这类问题不是人的大脑擅长解决的。计算机
恰好相反，它很难像人一样阅读和理解一段文字，但是对文字进行统计并告诉你出现频率最高的词及其出现次
数，对计算机而言是非常容易的：

~~~~ {.python}
    python words.py
    Enter file:words.txt
    to 16
~~~~

“个人信息分析助理”很快告诉我们，单词“to“在本章前三段中一共出现了16次。

事实上，计算机擅长做人类不擅长做的事，这就是为什么你需要熟练掌握一门“与计算机对话的语言”。一旦学
会这门新语言，你就可以将枯燥的工作指派给你的搭档（计算机）了。留出更多的时间去做适合你自己的事。
在这种合作关系中，你的贡献是才思、直觉力和创造力。

创新与动机
-------------------------

这本书不是为专业程序员准备的，专业编程是份非常有前途的工作，可算是物质与精神双丰收。为他人创造有用的、简洁的与智能的程序是一项创新性很强的活动。你的计算机或PDA通常安装了来自许多不同程序员开发的各种软件，每一款软件都想要吸引你的注意力和兴趣。它们尽其所能来满足你的需求，在使用过程中让你获得优质的用户体验。在某些情况下，当你选择了一个软件，这个软件的开发者就会因为你的选择而直接获得收益。

如果将程序看作是一群程序员的创造性产出，那么下图就是一个更形象的PDA模型：

![程序员在对你说](height=1.0in@../images/pda2)

本书的写作初衷不是为了赚钱或者取悦最终用户，而是让我们能更好地处理生活中的数据与信息。开始学编程，你既是程序员，也是你所写程序的最终用户。当你获得了程序员的技能，如果编程让你感到有创新活力的话，到时你的想法也许会发生改变，转向为他人开发程序也说不定。


计算机硬件架构
------------------------------

\index{hardware}
\index{hardware!architecture}

学习这种向计算机发指令来开发软件的语言之前，我们需要了解一下计算机的构成。
如果拆开你的计算机或者手机，仔细观察就会发现以下这些组件：

![硬件架构](height=1.75in@../images/arch)

这些组件的一般定义如下：

-   *中央处理器*（Central Processing Unit ，CPU）是专门为解决“下一步做什么”而存在的组件。如果计算机处理速度达到3.0 GHz，这就意味着CPU每秒会提问30亿次“下一步做什么？”。你不得不学会如何跟CPU如此快速地交谈与保持同步。

-   *主存储器*（Main Memory）用来存储CPU即刻需要的信息。主存储器的速度几乎与CPU不相上下。但是，关闭计算机之后主存储器里的信息也就消失了。

-   *辅助存储器*（Secondary Memory）也是用来存储信息的，但是它比主存储器速度慢很多。辅助存储器的优点是，它可以在计算机不带电情况下存储信息。常见辅助存储器包括磁盘和闪存。闪存通常用在U盘和便携式音乐播放器上。

-   *输入输出设备*（Input and Output Devices）包括屏幕、键盘、鼠标、麦克风、扬声器以及触摸板等。这些都是用来与计算机进行交互的设备。

-   如今大多数计算机之间还建立了 *网络连接*，通过网络获取信息。我们可以将网络看成信息存储与检索速度很慢的一个空间，而且不总是那么稳定。从某种意义上讲，网络是速度很慢且并不是那么可靠的 *辅助存储器*。

这些组件的工作原理细节最好还是交给计算机厂商吧。这里只是为了掌握一些术语，在编程时方便提及这些组件。

作为一名程序员，你的工作就是利用并协调这些资源来解决问题和分析数据。作为程序员，你主要与CPU打交道，告诉它下一步做什么。有时，你要告诉CPU调用主存储器、辅助存储器、网络或输入输出设备。

![Where Are You?](height=1.75in@../images/arch2)

你需要成为回答CPU“下一步做什么”的人。但把你压缩到5毫米高，塞入计算机，让你每秒发出3亿次命令，想必这样会很不舒服。所以，你必须提前写好你的指令。我们把这些存储下来的指令称为 *程序*，编写指令并进行调试的活动称之为 *编程*。

理解编程
-------------------------

在本书其他章节中，我们尝试把你培养成长为一名理解编程艺术并具备一定编程能力的人。最后，你会成为一个 *程序员*，也许不是专业的。但至少你掌握了如何看待数据（信息）分析问题，并开发出解决问题的程序。

\index{problem solving}

从某种意义上来说，程序员的养成需要两种技能：

-   首先，需要掌握编程语言（Python）本身—— 熟悉词汇和语法。能够准确地拼写这门新语言中的单词，并且掌握如何使用这门新语言正确地“造句”。

-   其次，学会讲故事。在写故事的过程中，通过文字和句式的组合，向读者传达思想。编故事的艺术与能力通过写作与反馈得以提高。在编程中，程序即故事，待解决的问题即传达的想法。

当掌握一种编程语言（如Python）之后，你会发现学习其他编程语言，如JavaScript或者C++，就会容易许多。虽然新的编程语言拥有很多不同的词汇和语法，但你已经学会解决问题的技能，所有编程语言本质上都是相通的。

Python的词汇和句式上手很快，但要能写出一些连贯的程序来解决一个全新的问题，尚需时日磨练。讲授编程就像讲授写作一样。先对程序进行阅读和解释，然后编写简单的程序，接着逐步编写更复杂的程序。当达到一定水平，你就形成了自己的编程风格，自然而然地去应对问题，通过编写程序解决它。一旦修炼到这个程度，编程就变成一个愉悦且富有创造力的过程了。

我们从Python程序的词汇和结构讲起。第一次阅读时，一定要耐心学习那些简单的例子。

词汇与句子
-------------------

\index{programming language}
\index{language!programming}

与人类语言不同的是，Python的词汇数量实际上相当少。我们称这些“词汇”为“保留字”，它们是Python中具有特殊意义的词汇。对于Python来说，程序中出现的这些词汇，它们有且仅有一个含义。等下你在编程时，你自己定义的词汇称为 *变量*。变量命名非常自由，但有一点，你不能使用Python的保留字作为变量名。

从某种意义上讲，我们训练一只狗时会使用一些特殊的词汇，比如“坐下”、“停下”和“拿来”。跟狗说话时不用这些保留字的话，它们就会傻傻地看着你，直到你对它说出保留字。举例来说，“我希望更多的人通过散步来促进健康。”，而大多数狗听到的可能是，“吧啦吧啦 *散步* 吧啦吧啦。”这是因为在狗的语言中“散步”是保留字。很多人可能觉得人类和猫之间的语言没有保留字^[<http://xkcd.com/231/>].

Python的保留字如下：

    and       del       global      not       with
    as        elif      if          or        yield
    assert    else      import      pass      
    break     except    in          raise
    class     finally   is          return
    continue  for       lambda      try
    def       from      nonlocal    while    

就这么多词汇。Python比狗训练有素多了。当你说“try”，Python会毫无差错地执行try。

后续章节会介绍这些保留字及它们的适用场合。现在，我们只关注怎么与Python *对话*（就像人跟狗说话）。教Python说话是件有意思的事情，把想要说的话用引号括起来就可以了。

~~~~ {.python}
    print('Hello world!')
~~~~

这就是我们写出的第一个语法正确的Python语句。我们的句子以函数 *print* 开头，后面跟一个文本字符串，用单引号括起来。

与Python对话
----------------------

我们已经掌握了Python的一个词汇与一个简单语句，接下来需要了解如何与Python对话，测试我们的新语言技能。

与Python对话之前，必须先在计算机上安装Python软件，学会如何启动Python。本章包含许多细节，建议查看 [www.py4e.com](http://www.py4e.com)，网站上有Python在Mac和Windows系统上配置和启动的详细说明和视频演示。当打开终端或者命令行窗口，输入python，Python解析器会以交互模式启动，如下所示：

\index{interactive mode}

~~~~ {.python}
    Python 3.5.1 (v3.5.1:37a07cee5969, Dec  6 2015, 01:54:25)
    [MSC v.1900 64 bit (AMD64)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
~~~~

‘>>>’提示符表示Python解析器在询问，“你希望我下一步做什么？”。Python已经准备好与你对话。你需要掌握的是怎样说Python语言，发起一个对话。

举个例子，你对Python语言最简单的词汇或句子一无所知，想要使用宇航员的标准用语（喊话）。宇航员在一个遥远的星球登陆，试着和这个星球的居民用以下语句对话:

~~~~ {.python}
    >>> I come in peace, please take me to your leader
      File "<stdin>", line 1
        I come in peace, please take me to your leader
             ^
    SyntaxError: invalid syntax
    >>>
~~~~

事情进展好像并不顺利。除非你反应迅速，否则这个星球的居民可能会拿长矛刺向你，向你吐口水，然后把你放在火上烤，当成晚饭吃掉。

幸运的是，旅行时你带了这本书，及时翻到了这一页，再试一次：

~~~~ {.python}
    >>> print('Hello world!')
    Hello world!
~~~~

这次看起来效果不错，试着与他们继续对话：

~~~~ {.python}
    >>> print('You must be the legendary god that comes from the sky')
    You must be the legendary god that comes from the sky
    >>> print('We have been waiting for you for a long time')
    We have been waiting for you for a long time
    >>> print('Our legend says you will be very tasty with mustard')
    Our legend says you will be very tasty with mustard
    >>> print 'We will have a feast tonight unless you say
      File "<stdin>", line 1
        print 'We will have a feast tonight unless you say
                                                         ^
    SyntaxError: Missing parentheses in call to 'print'
    >>>
~~~~

上面的对话一直进展顺利，只到你在使用Python语言的时候犯了一个非常小的错误，Python就又把长矛拿出来了。

此时，你应该意识到，Python虽然非常复杂与强大，但在语法上非常挑剔，并 *不* 那么智能。对话中必须使用正确的语法。

在某种意义上，当你使用别人写的程序时，Python就在你和其他程序员之间充当中间人。Python是程序编写者将对话进行下去的一种方式。在阅读完短短几章之后，你将成为Python程序员中的一员，与你的程序使用者进行对话。

结束与Python解析器的第一次谈话之前，你可能要知道如何正确地与这个星球的居民说“再见”：

~~~~ {.python}
    >>> good-bye
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'good' is not defined
    >>> if you don't mind, I need to leave
      File "<stdin>", line 1
        if you don't mind, I need to leave
                 ^
    SyntaxError: invalid syntax
    >>> quit()
~~~~

你会发现前两个错误提示是不同的。由于 *if* 是保留字，Python看到保留字会认为我们想说些什么，但句子的语法是错的。

跟Python说“再见”的正确方法是，在交互模式的提示符'>>>'后输入 *quit()*。猜出这个命令这可能会花费一些时间，所以手头备本书可能会派上用场。

术语：解释器与编译器
-------------------------------------

Python是一种 *高级语言*，旨在较为方便地让人类进行读写，让计算进行读取与处理。其他高级语言包括：Java、C++、PHP、Ruby、Basic、Perl以及JavaScript等。CPU里的硬件并不能理解任何一种高级语言。

CPU能理解的语言称之为 *机器语言*。机器语言非常简单，坦白讲，编写起来非常无聊。它全部由0和1组成：

~~~~
    001010001110100100101010000001111
    11100110000011101010010101101101
    ...
~~~~

虽然机器语言表面看起来很简单，只有0和1，但它的语法比Python复杂得多。所以，很少有程序员用机器语言编程。相反，借助各种翻译器，程序员可以编写像Python或JavaScript这样的高级语言，这些翻译器会将程序转换成机器语言，再交由CPU执行。

因为机器语言依附于计算机硬件，所以不能在不同类型硬件之间移植。使用高级语言编写的程序可以在不同的计算机之间移植，通过在另一台计算机上使用不同的编译器，或者重新编译代码，生成一个适合这台计算机的机器语言版本。

编程语言的翻译器大体可分为两类：(1)解释器 与 (2) 编译器。

*解释器* 读取程序员所写程序的源代码，解析源代码并实时解释指令。Python是一种解释器。当交互式执行Python时，输入一行Python语句，Python就会立即处理它，并做好准备让我们输入下一条语句。

Python语句中有一些地方会告诉Python，你想要Python记住等下会用到的一些数据。这时就需要为数据挑选一个名称来记住它，这样之后就可以通过这个名称来获取对应的数据了。我们使用 *变量*（variable）来代表存储的数据。

~~~~ {.python}
    >>> x = 6
    >>> print(x)
    6
    >>> y = x * 7
    >>> print(y)
    42
    >>>
~~~~

在这个例子中，我们让Python记住数值6，并将6赋值给变量 *x*，以便后续使用。为了确认Python已经记住这个数值，使用 *print* 命令打印它。接下来，我们让Python获取变量 *x* 的值并乘以7，然后将结果赋给新变量 *y*。最后，打印出变量 *y* 的当前值。

尽管我们一次只输入了一行命令，但Python将其视为一个语句序列，后面的语句可以获取前面语句的数据。四句组成的段落以一种有逻辑的和有意义的顺序编写，这就是我们写出的第一个简单的多行程序。

如上所示，解释器的本质是进行交互式对话。而编译器需要将整个程序放在一个文件中，将高层次的源代码翻译成低层次的机器语言，然后编译器将生成的机器语言放到一个文件中以便后续执行。

如果你使用Windows系统，这些可执行的机器语言程序通常带有“.exe”或“.dll”后缀，分别代表这是“可执行的”和“动态可加载库”。在Linux和Mac中没有这样的后缀来明确表示文件是否是可执行的。

如果在文本编辑器中打开一个可执行文件，满眼望去完全看不懂：

~~~~
    ^?ELF^A^A^A^@^@^@^@^@^@^@^@^@^B^@^C^@^A^@^@^@\xa0\x82
    ^D^H4^@^@^@\x90^]^@^@^@^@^@^@4^@ ^@^G^@(^@$^@!^@^F^@
    ^@^@4^@^@^@4\x80^D^H4\x80^D^H\xe0^@^@^@\xe0^@^@^@^E
    ^@^@^@^D^@^@^@^C^@^@^@^T^A^@^@^T\x81^D^H^T\x81^D^H^S
    ^@^@^@^S^@^@^@^D^@^@^@^A^@^@^@^A\^D^HQVhT\x83^D^H\xe8
    ....
~~~~

机器语言的读写并不容易，好在借助 *解释器* 和 *编译器*，能够使用Python或C这样的高级语言编写程序。

通过对解释器与编译器的讨论，你应该对Python解释器本身有了一些了解。你应该想问那它又是用什么语言写的？是用编译语言写的吗?当我们输入“python”，究竟发生了什么?

Python的解释器是用C语言编写的。你可以访问http://www.python.org网站，查看Python解释器的源代码，如有你有意愿改造这些源代码也是可以的。Python本身就是一个程序，它被编译成机器代码。当你（或计硬件供应商）在计算机上安装了Python，实际是上将一份编译好的Python程序的机器代码拷贝到你的计算机系统。在Windows中，Python可执行的机器代码很可能位于以下文件夹中:

~~~~
    C:\Python35\python.exe
~~~~

要成为一名Python程序员，你并不一定的需要知道上述这些。但在一开始，花一些时间解释这些细节问题，还是值得的。

编写一个程序
-----------------


在Python解析器中输入命令是体验Python功能非常好的方式，但不建议采用这种方式来解决复杂的问题。

编程时，我们在文本编辑器里把Python指令写到一个文件里，这个文件称为 *脚本*。一般而言，Python脚本以`.py`命名结尾。

\index{script}

要执行脚本，你必须告诉Python解释器脚本文件的名称。在Unix或Windows命令窗口中，你可以像下面这样执行`python hello.py`：

~~~~ {.bash}
    csev$ cat hello.py
    print('Hello world!')
    csev$ python hello.py
    Hello world!
    csev$
~~~~

“csev$”是操作系统提示符，“cat hello.py”是查看“hello.py”文件的内容，其中包含了一行打印字符串的Python程序。

我们调用Python解释器，告诉它从“hello.py”文件中读取源代码，而不是用命令行交互式一行一行地执行Python代码。

你会发现，没有必要在Python程序文件末尾加上 *quit()*。Python在读取源代码文件时，到达文件末尾它会自己停止。

什么是程序？
------------------

The definition of a *program* at its most basic is a
sequence of Python statements that have been crafted to do something.
Even our simple *hello.py* script is a program. It is a
one-line program and is not particularly useful, but in the strictest
definition, it is a Python program.

It might be easiest to understand what a program is by thinking about a
problem that a program might be built to solve, and then looking at a
program that would solve that problem.

Lets say you are doing Social Computing research on Facebook posts and
you are interested in the most frequently used word in a series of
posts. You could print out the stream of Facebook posts and pore over
the text looking for the most common word, but that would take a long
time and be very mistake prone. You would be smart to write a Python
program to handle the task quickly and accurately so you can spend the
weekend doing something fun.

For example, look at the following text about a clown and a car. Look at
the text and figure out the most common word and how many times it
occurs.

~~~~
    the clown ran after the car and the car ran into the tent
    and the tent fell down on the clown and the car
~~~~

Then imagine that you are doing this task looking at millions of lines
of text. Frankly it would be quicker for you to learn Python and write a
Python program to count the words than it would be to manually scan the
words.

The even better news is that I already came up with a simple program to
find the most common word in a text file. I wrote it, tested it, and now
I am giving it to you to use so you can save some time.

\VerbatimInput{../code3/words.py}
\begin{trinketfiles}
../code3/words.txt
\end{trinketfiles}

You don't even need to know Python to use this program. You will need to
get through Chapter 10 of this book to fully understand the awesome
Python techniques that were used to make the program. You are the end
user, you simply use the program and marvel at its cleverness and how it
saved you so much manual effort. You simply type the code into a file
called *words.py* and run it or you download the source
code from <http://www.py4e.com/code3/> and run it.

\index{program}

This is a good example of how Python and the Python language are acting
as an intermediary between you (the end user) and me (the programmer).
Python is a way for us to exchange useful instruction sequences (i.e.,
programs) in a common language that can be used by anyone who installs
Python on their computer. So neither of us are talking *to
Python*, instead we are communicating with each other
*through* Python.

The building blocks of programs
-------------------------------

In the next few chapters, we will learn more about the vocabulary,
sentence structure, paragraph structure, and story structure of Python.
We will learn about the powerful capabilities of Python and how to
compose those capabilities together to create useful programs.

There are some low-level conceptual patterns that we use to construct
programs. These constructs are not just for Python programs, they are
part of every programming language from machine language up to the
high-level languages.

input
:   Get data from the "outside world". This might be reading data from a
    file, or even some kind of sensor like a microphone or GPS. In our
    initial programs, our input will come from the user typing data on
    the keyboard.

output
:   Display the results of the program on a screen or store them in a
    file or perhaps write them to a device like a speaker to play music
    or speak text.

sequential execution
:   Perform statements one after another in the order they are
    encountered in the script.

conditional execution
:   Check for certain conditions and then execute or skip a sequence of
    statements.

repeated execution
:   Perform some set of statements repeatedly, usually with some
    variation.

reuse
:   Write a set of instructions once and give them a name and then reuse
    those instructions as needed throughout your program.

It sounds almost too simple to be true, and of course it is never so
simple. It is like saying that walking is simply "putting one foot in
front of the other". The "art" of writing a program is composing and
weaving these basic elements together many times over to produce
something that is useful to its users.

The word counting program above directly uses all of these patterns
except for one.

What could possibly go wrong?
-----------------------------

As we saw in our earliest conversations with Python, we must communicate
very precisely when we write Python code. The smallest deviation or
mistake will cause Python to give up looking at your program.

Beginning programmers often take the fact that Python leaves no room for
errors as evidence that Python is mean, hateful, and cruel. While Python
seems to like everyone else, Python knows them personally and holds a
grudge against them. Because of this grudge, Python takes our perfectly
written programs and rejects them as "unfit" just to torment us.

~~~~ {.python}
    >>> primt 'Hello world!'
      File "<stdin>", line 1
        primt 'Hello world!'
                           ^
    SyntaxError: invalid syntax
    >>> primt ('Hello world')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'primt' is not defined

    >>> I hate you Python!
      File "<stdin>", line 1
        I hate you Python!
             ^
    SyntaxError: invalid syntax
    >>> if you come out of there, I would teach you a lesson
      File "<stdin>", line 1
        if you come out of there, I would teach you a lesson
                  ^
    SyntaxError: invalid syntax
    >>>
~~~~

There is little to be gained by arguing with Python. It is just a tool.
It has no emotions and it is happy and ready to serve you whenever you
need it. Its error messages sound harsh, but they are just Python's call
for help. It has looked at what you typed, and it simply cannot
understand what you have entered.

Python is much more like a dog, loving you unconditionally, having a few
key words that it understands, looking you with a sweet look on its face
(`>>>`), and waiting for you to say something it
understands. When Python says "SyntaxError: invalid syntax", it is
simply wagging its tail and saying, "You seemed to say something but I
just don't understand what you meant, but please keep talking to me
(`>>>`)."

As your programs become increasingly sophisticated, you will encounter
three general types of errors:

Syntax errors
:   These are the first errors you will make and the easiest to fix. A
    syntax error means that you have violated the "grammar" rules of
    Python. Python does its best to point right at the line and
    character where it noticed it was confused. The only tricky bit of
    syntax errors is that sometimes the mistake that needs fixing is
    actually earlier in the program than where Python
    *noticed* it was confused. So the line and character
    that Python indicates in a syntax error may just be a starting point
    for your investigation.

Logic errors
:   A logic error is when your program has good syntax but there is a
    mistake in the order of the statements or perhaps a mistake in how
    the statements relate to one another. A good example of a logic
    error might be, "take a drink from your water bottle, put it in your
    backpack, walk to the library, and then put the top back on the
    bottle."

Semantic errors
:   A semantic error is when your description of the steps to take is
    syntactically perfect and in the right order, but there is simply a
    mistake in the program. The program is perfectly correct but it does
    not do what you *intended* for it to do. A simple
    example would be if you were giving a person directions to a
    restaurant and said, "...when you reach the intersection with the
    gas station, turn left and go one mile and the restaurant is a red
    building on your left." Your friend is very late and calls you to
    tell you that they are on a farm and walking around behind a barn,
    with no sign of a restaurant. Then you say "did you turn left or
    right at the gas station?" and they say, "I followed your directions
    perfectly, I have them written down, it says turn left and go one
    mile at the gas station." Then you say, "I am very sorry, because
    while my instructions were syntactically correct, they sadly
    contained a small but undetected semantic error.".

Again in all three types of errors, Python is merely trying its hardest
to do exactly what you have asked.

The learning journey
--------------------

As you progress through the rest of the book, don't be afraid if the
concepts don't seem to fit together well the first time. When you were
learning to speak, it was not a problem for your first few years that
you just made cute gurgling noises. And it was OK if it took six months
for you to move from simple vocabulary to simple sentences and took 5-6
more years to move from sentences to paragraphs, and a few more years to
be able to write an interesting complete short story on your own.

We want you to learn Python much more rapidly, so we teach it all at the
same time over the next few chapters. But it is like learning a new
language that takes time to absorb and understand before it feels
natural. That leads to some confusion as we visit and revisit topics to
try to get you to see the big picture while we are defining the tiny
fragments that make up that big picture. While the book is written
linearly, and if you are taking a course it will progress in a linear
fashion, don't hesitate to be very nonlinear in how you approach the
material. Look forwards and backwards and read with a light touch. By
skimming more advanced material without fully understanding the details,
you can get a better understanding of the "why?" of programming. By
reviewing previous material and even redoing earlier exercises, you will
realize that you actually learned a lot of material even if the material
you are currently staring at seems a bit impenetrable.

Usually when you are learning your first programming language, there are
a few wonderful "Ah Hah!" moments where you can look up from pounding
away at some rock with a hammer and chisel and step away and see that
you are indeed building a beautiful sculpture.

If something seems particularly hard, there is usually no value in
staying up all night and staring at it. Take a break, take a nap, have a
snack, explain what you are having a problem with to someone (or perhaps
your dog), and then come back to it with fresh eyes. I assure you that
once you learn the programming concepts in the book you will look back
and see that it was all really easy and elegant and it simply took you a
bit of time to absorb it.

Glossary
--------

bug
:   An error in a program.
\index{bug}

central processing unit
:   The heart of any computer. It is what runs the software that we
    write; also called "CPU" or "the processor".
\index{central processing unit}
\index{CPU}

compile
:   To translate a program written in a high-level language into a
    low-level language all at once, in preparation for later execution.
\index{compile}

high-level language
:   A programming language like Python that is designed to be easy for
    humans to read and write.
\index{high-level language}

interactive mode
:   A way of using the Python interpreter by typing commands and
    expressions at the prompt.
\index{interactive mode}

interpret
:   To execute a program in a high-level language by translating it one
    line at a time.
\index{interpret}

low-level language
:   A programming language that is designed to be easy for a computer to
    execute; also called "machine code" or "assembly language".
\index{low-level language}

machine code
:   The lowest-level language for software, which is the language that
    is directly executed by the central processing unit (CPU).
\index{machine code}

main memory
:   Stores programs and data. Main memory loses its information when the
    power is turned off.
\index{main memory}

parse
:   To examine a program and analyze the syntactic structure.
\index{parse}

portability
:   A property of a program that can run on more than one kind of
    computer.
\index{portability}

print function
:   An instruction that causes the Python interpreter to display a value
    on the screen.
\index{print function}
\index{function!print}

problem solving
:   The process of formulating a problem, finding a solution, and
    expressing the solution.
\index{problem solving}

program
:   A set of instructions that specifies a computation.
\index{program}

prompt
:   When a program displays a message and pauses for the user to type
    some input to the program.
\index{prompt}

secondary memory
:   Stores programs and data and retains its information even when the
    power is turned off. Generally slower than main memory. Examples of
    secondary memory include disk drives and flash memory in USB sticks.
\index{secondary memory}

semantics
:   The meaning of a program.
\index{semantics}

semantic error
:   An error in a program that makes it do something other than what the
    programmer intended.
\index{semantic error}

source code
:   A program in a high-level language.
\index{source code}

Exercises
---------

Exercise 1: What is the function of the secondary memory in a computer?

a\) Execute all of the computation and logic of the program\
b) Retrieve web pages over the Internet\
c) Store information for the long term, even beyond a power cycle\
d) Take input from the user

Exercise 2: What is a program?

Exercise 3: What is the difference between a compiler and an
interpreter?

Exercise 4: Which of the following contains "machine code"?

a\) The Python interpreter\
b) The keyboard\
c) Python source file\
d) A word processing document

Exercise 5: What is wrong with the following code:

~~~~ {.python}
    >>> primt 'Hello world!'
      File "<stdin>", line 1
        primt 'Hello world!'
                           ^
    SyntaxError: invalid syntax
    >>>
~~~~

Exercise 6: Where in the computer is a variable such as "X" stored after
the following Python line finishes?

~~~~ {.python}
    x = 123
~~~~

a\) Central processing unit\
b) Main Memory\
c) Secondary Memory\
d) Input Devices\
e) Output Devices

Exercise 7: What will the following program print out:

~~~~ {.python}
    x = 43
    x = x + 1
    print(x)
~~~~

a\) 43\
b) 44\
c) x + 1\
d) Error because x = x + 1 is not possible mathematically

Exercise 8: Explain each of the following using an example of a human
capability: (1) Central processing unit, (2) Main Memory, (3) Secondary
Memory, (4) Input Device, and (5) Output Device. For example, "What is
the human equivalent to a Central Processing Unit"?

Exercise 9: How do you fix a "Syntax Error"?
